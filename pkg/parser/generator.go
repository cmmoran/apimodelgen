package parser

import (
	"path/filepath"
	"slices"
	"sort"
	"strings"

	"github.com/dave/jennifer/jen"

	"github.com/cmmoran/apimodelgen/pkg/model"
)

func (p *Parser) GenerateApiFile() *jen.File {
	f := jen.NewFile(p.Package())
	f.HeaderComment("// Code generated by apimodelgen; DO NOT EDIT.")

	// ---------------------------------------------------------------
	// IMPORTS
	// ---------------------------------------------------------------
	for alias, meta := range p.ApiImports {
		if meta.Mod {
			continue
		}
		f.ImportName(meta.Path, alias)
	}
	f.Line()

	// ---------------------------------------------------------------
	// PatchSlice[T any]
	//
	// PatchSlice encodes user intent for patching slice fields.
	// Semantics:
	//   - At most ONE of Replace, Patch, Add, Remove may be non-nil.
	//   - Replace: the slice is replaced entirely with *Replace.
	//   - Patch:   existing elements are patched by key.
	//   - Add:     elements are appended.
	//   - Remove:  elements are removed by key.
	//
	// Element key resolution (server-side, not enforced here):
	//   1. Field with `dto:"id"` tag (highest precedence).
	//   2. Field with `gorm:"primaryKey"` tag.
	//   3. Field named "ID" or with json:"id".
	//   If none exist, Patch/Remove should be treated as unsupported or
	//   must use whole-element comparison.
	// ---------------------------------------------------------------
	f.Type().
		Id("PatchSlice").
		Types(jen.Id("T").Any()).
		Struct(
			jen.Id("Replace").Op("*").Index().Id("T").
				Tag(map[string]string{
					"json":         "replace,omitempty",
					"mapstructure": "replace,omitempty",
					"yaml":         "replace,omitempty",
					"toml":         "replace,omitempty",
				}),
			jen.Id("Patch").Op("*").Index().Id("T").
				Tag(map[string]string{
					"json":         "patch,omitempty",
					"mapstructure": "patch,omitempty",
					"yaml":         "patch,omitempty",
					"toml":         "patch,omitempty",
				}),
			jen.Id("Add").Op("*").Index().Id("T").
				Tag(map[string]string{
					"json":         "add,omitempty",
					"mapstructure": "add,omitempty",
					"yaml":         "add,omitempty",
					"toml":         "add,omitempty",
				}),
			jen.Id("Remove").Op("*").Index().Id("T").
				Tag(map[string]string{
					"json":         "remove,omitempty",
					"mapstructure": "remove,omitempty",
					"yaml":         "remove,omitempty",
					"toml":         "remove,omitempty",
				}),
		)

	f.Line()

	// Validate enforces that at most one of Replace, Patch, Add, Remove is set.
	f.Func().
		Params(
			jen.Id("ps").Op("*").Id("PatchSlice").Types(jen.Id("T")),
		).
		Id("Validate").
		Params().
		Error().
		Block(
			jen.If(jen.Id("ps").Op("==").Nil()).Block(
				jen.Return(jen.Nil()),
			),
			jen.Id("count").Op(":=").Lit(0),
			jen.If(jen.Id("ps").Dot("Replace").Op("!=").Nil()).Block(
				jen.Id("count").Op("++"),
			),
			jen.If(jen.Id("ps").Dot("Patch").Op("!=").Nil()).Block(
				jen.Id("count").Op("++"),
			),
			jen.If(jen.Id("ps").Dot("Add").Op("!=").Nil()).Block(
				jen.Id("count").Op("++"),
			),
			jen.If(jen.Id("ps").Dot("Remove").Op("!=").Nil()).Block(
				jen.Id("count").Op("++"),
			),
			jen.If(jen.Id("count").Op(">").Lit(1)).Block(
				jen.Return(
					jen.Qual("fmt", "Errorf").Call(
						jen.Lit("PatchSlice: only one of Replace, Patch, Add, Remove may be non-nil"),
					),
				),
			),
			jen.Return(jen.Nil()),
		)

	f.Line()

	sort.Sort(p.ApiStructs)
	// ---------------------------------------------------------------
	// STRUCT TYPES (DTO, Patch, Plurals, Aliases)
	// ---------------------------------------------------------------
	for _, api := range p.ApiStructs {
		if len(p.Opts.ExcludeTypes) > 0 {
			check := api.Name
			if len(p.Opts.Suffix) > 0 {
				check = strings.TrimSuffix(api.Name, p.Opts.Suffix)
			}
			if slices.Contains(p.Opts.ExcludeTypes, check) {
				continue
			}
		}

		// ALIAS TYPE (slice aliases)
		if api.Alias != nil {
			if len(p.Opts.ExcludeTypes) > 0 {
				check := *api.Alias
				if len(p.Opts.Suffix) > 0 {
					check = strings.TrimSuffix(*api.Alias, p.Opts.Suffix)
				}
				if slices.Contains(p.Opts.ExcludeTypes, check) {
					continue
				}
			}
			if api.AliasPtr != nil && *api.AliasPtr {
				f.Type().
					Id(api.Name).
					Index().
					Op("*").
					Id(*api.Alias)
			} else {
				f.Type().
					Id(api.Name).
					Index().
					Id(*api.Alias)
			}
			f.Line()
			continue
		}

		// Is this a Patch struct?
		isPatchStruct := strings.HasSuffix(api.Name, p.Opts.PatchSuffix)

		// NORMAL STRUCT DECLARATION
		f.Type().Id(api.Name).StructFunc(func(g *jen.Group) {
			for _, fld := range api.Fields {
				// Name as known in the model (for patch structs, map keys, etc).
				name := fld.Name

				var ff *jen.Statement

				// Anonymous embedded field in DTOs when IncludeEmbedded is active.
				// For Patch structs we always keep a named pointer field.
				if fld.IsEmbedded && !isPatchStruct && p.Opts.IncludeEmbedded {
					ff = g.Add(p.typeExprToJen(fld.Type))
				} else {
					ff = g.Id(name).Add(p.typeExprToJen(fld.Type))
				}

				if fld.Tag != "" {
					fldTag := strings.Trim(string(fld.Tag), "`")
					tagMap := map[string]string{}
					for _, kv := range strings.Split(fldTag, " ") {
						parts := strings.SplitN(kv, ":", 2)
						if len(parts) == 2 {
							tagMap[parts[0]] = strings.Trim(parts[1], `"`)
						}
					}
					ff.Tag(tagMap)
				}
			}
		})
		f.Line()
	}

	// ---------------------------------------------------------------
	// ToPatch() GENERATION
	// ---------------------------------------------------------------
	for _, api := range p.ApiStructs {

		// Skip alias types — they never get ToPatch()
		if api.Alias != nil {
			continue
		}

		// Skip Patch types themselves
		if strings.HasSuffix(api.Name, p.Opts.PatchSuffix) {
			continue
		}

		// Skip excluded types
		if len(p.Opts.ExcludeTypes) > 0 {
			check := api.Name
			if len(p.Opts.Suffix) > 0 {
				check = strings.TrimSuffix(api.Name, p.Opts.Suffix)
			}
			if slices.Contains(p.Opts.ExcludeTypes, check) {
				continue
			}
		}

		// Patch type name based on Option C
		patchName := api.Name + p.Opts.PatchSuffix
		patch := p.ApiStructs.Find(patchName)
		if patch == nil {
			// No matching patch struct → skip
			continue
		}

		// Generate:
		//
		// func (dto XxxDTO) ToPatch() XxxDTOPatch {
		//     return XxxDTOPatch{
		//         Field: &dto.Field,
		//         Slice: &PatchSlice[ElemPatch]{ ... },
		//     }
		// }
		//
		f.Func().
			Params(jen.Id("dto").Id(api.Name)).
			Id("ToPatch").
			Params().
			Id(patchName).
			BlockFunc(func(g *jen.Group) {

				g.Return(
					jen.Id(patchName).Values(
						jen.DictFunc(func(d jen.Dict) {

							for _, fld := range api.Fields {

								if p.isExcludedBaseType(fld.Type) {
									continue
								}

								pfield := findPatchField(patch, fld.Name)
								if pfield == nil {
									continue
								}

								rhs := p.rhsExprForPatch(fld, pfield)
								d[jen.Id(pfield.Name)] = rhs
							}
						}),
					),
				)
			})

		f.Line()
	}

	return f
}

func findPatchField(patch *model.ApiStruct, name string) *model.ApiField {
	for _, f := range patch.Fields {
		if f.Name == name {
			return f
		}
	}
	return nil
}

func (p *Parser) rhsExprForPatch(api *model.ApiField, patch *model.ApiField) jen.Code {
	t := api.Type
	pt := patch.Type

	// PatchSlice[...] always starts nil
	if pt.Name == "PatchSlice" {
		return jen.Nil()
	}

	// Compute the selector name for dto.<selector>.
	// For embedded fields (especially anonymous ones), we want to reference
	// the DTO's embedded type name (e.g. TestEmbeddedDTO, TestEmbeddedGenericDTO).
	selector := api.Name
	if api.IsEmbedded && (selector == "" || selector == patch.Name) && api.Type != nil && api.Type.Name != "" {
		selector = api.Type.Name
	}

	// Respect read-only/create-only → do NOT pointerize
	if p.isGormReadOnly(api.RawTag) {
		return jen.Id("dto").Dot(selector)
	}

	apiDepth := ptrDepth(t)
	patchDepth := ptrDepth(pt)

	diff := patchDepth - apiDepth

	switch diff {

	case 0:
		// Same pointer depth — pass through directly
		return jen.Id("dto").Dot(selector)

	case 1:
		// Need one extra level of pointer.
		// Safe even when dto.Field == zero-value.
		if isPatchStructRef(t, pt, p.Opts.PatchSuffix) {
			return jen.Parens(
				jen.Func().Params().Add(p.typeExprToJen(pt)).Block(
					jen.Id("tmp").Op(":=").Id("dto").Dot(selector).Dot("ToPatch").Call(),
					jen.Return(jen.Op("&").Id("tmp")),
				).Call(),
			)
		}
		return jen.Op("&").Parens(jen.Id("dto").Dot(selector))

	default:
		// More than one level → only address if non-nil
		// if dto.F == nil → nil
		// else → &dto.F
		return jen.Parens(
			jen.Func().Params().Add(jen.Id(pt.Name)).Block(
				jen.If(jen.Id("dto").Dot(selector).Op("==").Nil()).Block(
					jen.Return(jen.Nil()),
				),
				jen.Return(jen.Op("&").Parens(jen.Id("dto").Dot(selector))),
			).Call(),
		)
	}
}

func ptrDepth(t *model.TypeRef) int {
	depth := 0
	for t != nil && t.IsPtr {
		depth++
		t = t.Elem
	}
	return depth
}

// isPatchStructRef reports whether pt refers to the PATCH version of t
// (Foo → FooPatch), ignoring pointer/slice wrappers.
func isPatchStructRef(t, pt *model.TypeRef, patchSuffix string) bool {
	base := leafName(t)
	patch := leafName(pt)
	if base == "" || patch == "" {
		return false
	}
	return patch == base+patchSuffix
}

func leafName(t *model.TypeRef) string {
	for t != nil {
		if t.Elem == nil {
			return t.Name
		}
		t = t.Elem
	}
	return ""
}

func (p *Parser) Package() string {
	return filepath.Base(p.Opts.OutDir)
}

// typeExprToJen converts your model.TypeRef into a jen.Code snippet.
// Supports:
//   - pointers
//   - slices
//   - imported types (using p.Imports aliases)
//   - generic PatchSlice[T] (with optional pointer)
func (p *Parser) typeExprToJen(t *model.TypeRef) jen.Code {
	if t == nil {
		return jen.Id("interface{}")
	}

	// ---------------------------------------------------------------
	// GENERIC PatchSlice[T] handling
	// ---------------------------------------------------------------
	if t.Name == "PatchSlice" && t.Elem != nil {
		// PatchSlice[T] or *PatchSlice[T]
		base := jen.Id("PatchSlice").Types(p.typeExprToJen(t.Elem))
		if t.IsPtr {
			return jen.Op("*").Add(base)
		}
		return base
	}

	// ---------------------------------------------------------------
	// POINTERS
	// ---------------------------------------------------------------
	if t.IsPtr && t.Elem != nil {
		return jen.Op("*").Add(p.typeExprToJen(t.Elem))
	}

	// ---------------------------------------------------------------
	// SLICES
	// ---------------------------------------------------------------
	if t.IsSlice && t.Elem != nil {
		return jen.Index().Add(p.typeExprToJen(t.Elem))
	}

	// ---------------------------------------------------------------
	// IMPORTED TYPE
	// ---------------------------------------------------------------
	if t.PkgPath != "" {
		for _, meta := range p.Imports {
			if meta.Path == t.PkgPath && !meta.Mod {
				return jen.Qual(meta.Path, t.Name)
			}
		}
	}

	// ---------------------------------------------------------------
	// LOCAL / BUILTIN TYPE
	// ---------------------------------------------------------------
	return jen.Id(t.Name)
}
